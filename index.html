<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cosmic Lipstick - Phase 4</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #050505; cursor: none; }
    canvas { display: block; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- ゲームデータ ---
let player = { x: 100, y: canvas.height / 2, width: 60, height: 30, colorBody: '#FF69B4', colorTip: '#FF1493' };
let mouseY = canvas.height / 2;
let bullets = [];
let paintTrails = [];
let stars = [];
let enemies = []; // 敵を入れる配列
let score = 0;

// 星空の初期化
for (let i = 0; i < 150; i++) {
    stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 1.5, opacity: Math.random(), twinkleSpeed: 0.02 + Math.random() * 0.05 });
}

// --- イベントリスナー ---
window.addEventListener('mousemove', (e) => { mouseY = e.clientY; });
window.addEventListener('mousedown', () => {
    bullets.push({ x: player.x + player.width/2, y: player.y, speed: 20, size: 25 });
});

// --- 敵の生成ロジック (Phase 4 追加) ---
function spawnEnemy() {
    if (Math.random() < 0.02) { // 約2%の確率で毎フレーム生成
        enemies.push({
            x: canvas.width + 100,
            y: Math.random() * canvas.height,
            width: 50,
            height: 30,
            speed: 3 + Math.random() * 5,
            hp: 1
        });
    }
}

// --- 描画と更新 ---

function drawStars() {
    ctx.fillStyle = "white";
    stars.forEach(s => {
        s.opacity += s.twinkleSpeed;
        if (s.opacity > 1 || s.opacity < 0) s.twinkleSpeed *= -1;
        ctx.globalAlpha = Math.abs(s.opacity);
        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1.0;
}

function drawPaintedArea(time) {
    if (paintTrails.length === 0) return;
    ctx.save();
    ctx.beginPath();
    paintTrails.forEach(p => { ctx.moveTo(p.x, p.y); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); });
    ctx.clip();
    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width);
    const intensity = Math.sin(time * 0.05) * 20 + 40;
    gradient.addColorStop(0, `hsl(300, 100%, ${intensity}%)`);
    gradient.addColorStop(1, '#220022');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.x -= e.speed; // 左へ進む

        // --- 当たり判定 (弾 vs 敵) ---
        bullets.forEach((b, bi) => {
            // 弾と敵の距離を計算（円と四角の簡易判定）
            if (b.x > e.x && b.x < e.x + e.width && b.y > e.y - e.height/2 && b.y < e.y + e.height/2) {
                e.hp -= 1;
                // 当たった場所もピンクに染める！
                paintTrails.push({ x: e.x + e.width/2, y: e.y, radius: 80 }); 
            }
        });

        if (e.hp <= 0) {
            enemies.splice(i, 1);
            score += 10;
            continue;
        }

        // 敵の描画 (死んだ魚風のグレーの影)
        ctx.save();
        ctx.fillStyle = "#555"; // グレー
        ctx.beginPath();
        ctx.ellipse(e.x + e.width/2, e.y, e.width/2, e.height/2, 0, 0, Math.PI * 2);
        ctx.fill();
        // 魚の尾びれっぽいやつ
        ctx.beginPath();
        ctx.moveTo(e.x + e.width, e.y);
        ctx.lineTo(e.x + e.width + 15, e.y - 10);
        ctx.lineTo(e.x + e.width + 15, e.y + 10);
        ctx.fill();
        ctx.restore();

        if (e.x < -100) enemies.splice(i, 1);
    }
}

function updateBullets() {
    bullets.forEach((b) => {
        b.x += b.speed;
        paintTrails.push({ x: b.x, y: b.y, radius: b.size });
        ctx.save();
        ctx.shadowBlur = 15; ctx.shadowColor = '#FF00FF';
        ctx.fillStyle = 'rgba(255, 20, 147, 0.9)';
        ctx.beginPath(); ctx.ellipse(b.x, b.y, b.size, b.size/3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    });
    bullets = bullets.filter(b => b.x < canvas.width + 50);
}

function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.shadowBlur = 20; ctx.shadowColor = player.colorBody;
    ctx.fillStyle = player.colorBody;
    ctx.beginPath(); ctx.roundRect(-player.width/2, -player.height/2, player.width*0.7, player.height, [5, 0, 0, 5]); ctx.fill();
    ctx.fillStyle = player.colorTip;
    ctx.beginPath(); ctx.moveTo(player.width*0.2, -player.height/2 + 5); ctx.lineTo(player.width/2, -player.height/4); ctx.lineTo(player.width/2, player.height/4); ctx.lineTo(player.width*0.2, player.height/2 - 5); ctx.closePath(); ctx.fill();
    ctx.restore();
}

// --- メインループ ---
let frameTime = 0;
function gameLoop() {
    frameTime++;
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawStars();
    drawPaintedArea(frameTime);
    
    spawnEnemy();    // 敵を出す
    updateEnemies(); // 敵を動かして当たり判定
    
    player.y += (mouseY - player.y) * 0.1;
    updateBullets();
    drawPlayer();

    // スコア表示
    ctx.fillStyle = "white";
    ctx.font = "20px Arial";
    ctx.fillText(`PURIFIED: ${score}`, 20, 40);

    requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
