<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cosmic Lipstick - Phase 5 (Gyaru Fish!)</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #050505; cursor: none; font-family: 'Arial', sans-serif; }
    canvas { display: block; }
    #gameOver {
        display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        color: #FF00FF; text-align: center; background: rgba(0,0,0,0.8); padding: 20px; border: 5px solid #FF00FF;
    }
</style>
</head>
<body>
<div id="gameOver">
    <h1>GAME OVER</h1>
    <p>You were too dry...</p>
    <button onclick="location.reload()">RETRY</button>
</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// --- ゲームデータ ---
let player = { x: 100, y: canvas.height / 2, width: 60, height: 30, colorBody: '#FF69B4', colorTip: '#FF1493' };
let mouseY = canvas.height / 2;
let bullets = [];
let paintTrails = [];
let stars = [];
let enemies = [];
let score = 0;
let isGameOver = false;

// 星空の初期化
for (let i = 0; i < 150; i++) {
    stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 1.5, opacity: Math.random(), twinkleSpeed: 0.02 + Math.random() * 0.05 });
}

window.addEventListener('mousemove', (e) => { if(!isGameOver) mouseY = e.clientY; });
window.addEventListener('mousedown', () => {
    if(!isGameOver) bullets.push({ x: player.x + player.width/2, y: player.y, speed: 22, size: 28 });
});

function spawnEnemy() {
    if (Math.random() < 0.025) {
        enemies.push({
            x: canvas.width + 100, y: Math.random() * canvas.height,
            width: 70, height: 40, speed: 4 + Math.random() * 4,
            status: 'normal', // 'normal' または 'purified' (ギャル)
            timer: 0 // 演出用
        });
    }
}

function drawStars() {
    ctx.fillStyle = "white";
    stars.forEach(s => {
        s.opacity += s.twinkleSpeed;
        if (s.opacity > 1 || s.opacity < 0) s.twinkleSpeed *= -1;
        ctx.globalAlpha = Math.abs(s.opacity);
        ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1.0;
}

function drawPaintedArea(time) {
    if (paintTrails.length === 0) return;
    ctx.save();
    ctx.beginPath();
    paintTrails.forEach(p => { ctx.moveTo(p.x, p.y); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); });
    ctx.clip();
    const gradient = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width);
    gradient.addColorStop(0, `hsl(300, 100%, ${Math.sin(time * 0.05) * 20 + 40}%)`);
    gradient.addColorStop(1, '#220022');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
}

function drawFish(e) {
    ctx.save();
    ctx.translate(e.x, e.y);
    
    if (e.status === 'normal') {
        // --- キモいグレーの魚 ---
        ctx.fillStyle = "#666";
        // 体
        ctx.beginPath(); ctx.ellipse(0, 0, e.width/2, e.height/2, 0, 0, Math.PI * 2); ctx.fill();
        // 尾びれ
        ctx.beginPath(); ctx.moveTo(e.width/2, 0); ctx.lineTo(e.width/2+20, -15); ctx.lineTo(e.width/2+20, 15); ctx.fill();
        // 死んだ目
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(-15, -5, 8, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "black"; ctx.beginPath(); ctx.arc(-15, -5, 3, 0, Math.PI * 2); ctx.fill();
        // 半開きの口
        ctx.strokeStyle = "black"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(-25, 10, 5, 0, Math.PI); ctx.stroke();
    } else {
        // --- キモいギャル魚 (浄化後) ---
        ctx.shadowBlur = 20; ctx.shadowColor = "#FF00FF";
        ctx.fillStyle = "#FF69B4"; // どピンク
        // 体
        ctx.beginPath(); ctx.ellipse(0, 0, e.width/1.5, e.height/1.5, 0, 0, Math.PI * 2); ctx.fill();
        // 巨大な唇 (グロス盛り)
        ctx.fillStyle = "#FF1493";
        ctx.beginPath(); ctx.ellipse(-30, 10, 15, 8, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.ellipse(-25, 8, 5, 2, 0, 0, Math.PI * 2); ctx.fill(); // テカリ
        // つけまつげ付きの目
        ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(-20, -10, 12, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#00FFFF"; ctx.beginPath(); ctx.arc(-20, -10, 6, 0, Math.PI * 2); ctx.fill(); // カラーコンタクト
        // つけま（線で描く）
        ctx.strokeStyle = "black"; ctx.lineWidth = 3;
        for(let i=0; i<3; i++) {
            ctx.beginPath(); ctx.moveTo(-25 + i*5, -20); ctx.lineTo(-30 + i*5, -35); ctx.stroke();
        }
    }
    ctx.restore();
}

function updateEnemies() {
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];

        if (e.status === 'normal') {
            e.x -= e.speed;
            
            // 当たり判定 (弾 vs 敵)
            bullets.forEach((b) => {
                if (Math.hypot(b.x - e.x, b.y - e.y) < 50) {
                    e.status = 'purified';
                    score += 10;
                    paintTrails.push({ x: e.x, y: e.y, radius: 100 });
                }
            });

            // 当たり判定 (プレイヤー vs 敵) -> ゲームオーバー
            if (Math.hypot(player.x - e.x, player.y - e.y) < 40) {
                isGameOver = true;
                document.getElementById('gameOver').style.display = 'block';
            }
        } else {
            // 浄化後の動き (斜め上に高速で去る)
            e.x += 10; e.y -= 15;
            e.timer++;
            // キラキラを出す
            if(e.timer % 2 === 0) paintTrails.push({ x: e.x, y: e.y, radius: 20 });
        }

        drawFish(e);
        if (e.x < -200 || e.y < -200 || e.x > canvas.width + 500) enemies.splice(i, 1);
    }
}

function updateBullets() {
    bullets.forEach((b) => {
        b.x += b.speed;
        paintTrails.push({ x: b.x, y: b.y, radius: b.size });
        ctx.save();
        ctx.shadowBlur = 15; ctx.shadowColor = '#FF00FF';
        ctx.fillStyle = 'rgba(255, 20, 147, 0.9)';
        ctx.beginPath(); ctx.ellipse(b.x, b.y, b.size, b.size/3, 0, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    });
    bullets = bullets.filter(b => b.x < canvas.width + 50);
}

function drawPlayer() {
    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.shadowBlur = 20; ctx.shadowColor = player.colorBody;
    ctx.fillStyle = player.colorBody;
    ctx.beginPath(); ctx.roundRect(-player.width/2, -player.height/2, player.width*0.7, player.height, [5, 0, 0, 5]); ctx.fill();
    ctx.fillStyle = player.colorTip;
    ctx.beginPath(); ctx.moveTo(player.width*0.2, -player.height/2 + 5); ctx.lineTo(player.width/2, -player.height/4); ctx.lineTo(player.width/2, player.height/4); ctx.lineTo(player.width*0.2, player.height/2 - 5); ctx.closePath(); ctx.fill();
    ctx.restore();
}

function gameLoop() {
    if (isGameOver) return;
    
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawStars();
    drawPaintedArea(Date.now() / 20);
    spawnEnemy();
    updateEnemies();
    player.y += (mouseY - player.y) * 0.1;
    updateBullets();
    drawPlayer();

    ctx.fillStyle = "white"; ctx.font = "bold 24px Arial";
    ctx.fillText(`PURIFIED: ${score}`, 20, 50);

    requestAnimationFrame(gameLoop);
}
gameLoop();
</script>
</body>
</html>
